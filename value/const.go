// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file contains 1024-digit string representations of fundamental constants.
// They are stored in 3400-bit Floats, almost sufficient to represent the values.
// When used in calculations, those Floats are truncated to the precision of the operands.

// In the unlikely event more digits are needed, it's easy to find the values online and
// lengthen the constants.

package value

import "math/big"

const constPrecision = 3400 // 1024*log(10)/log(2) == 3401.6

var (
	// set to constPrecision
	floatE  *big.Float
	floatPi *big.Float
	// set to default precision
	_E  BigFloat
	_PI BigFloat
)

const strE = "2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921817413596629043572900334295260595630738132328627943490763233829880753195251019011573834187930702154089149934884167509244761460668082264800168477411853742345442437107539077744992069551702761838606261331384583000752044933826560297606737113200709328709127443747047230696977209310141692836819025515108657463772111252389784425056953696770785449969967946864454905987931636889230098793127736178215424999229576351482208269895193668033182528869398496465105820939239829488793320362509443117301238197068416140397019837679320683282376464804295311802328782509819455815301756717361332069811250996181881593041690351598888519345807273866738589422879228499892086805825749279610484198444363463244968487560233624827041978623209002160990235304369941849146314093431738143640546253152096183690888707016768396424378140592714563549061303107208510383750510115747704171898610687396965521267154688957035035402123407849819334321068"

const strPi = "3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198938095257201065485863278"

func newF() *big.Float {
	return big.NewFloat(0, conf.FloatPrec(), big.ToNearestEven)
}

func Consts() (e, pi BigFloat) {
	if conf.FloatPrec() > constPrecision {
		Errorf("precision too high; only have %d bits of precision for e and pi", constPrecision)
	}
	var ok bool
	floatE, ok = newF().SetString(strE)
	if !ok {
		panic("setting e")
	}
	floatPi, ok = newF().SetString(strPi)
	if !ok {
		panic("setting pi")
	}
	return BigFloat{newF().Set(floatE)}, BigFloat{newF().Set(floatPi)}
}
